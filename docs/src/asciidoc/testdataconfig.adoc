[[testdataconfig]]
== Test Data Config
If you want to specify global defaults, you will need to create a `TestDataConfig.groovy` (using the examples below as a starting point):

    src/test/resources/TestDataConfig.groovy

The config file is most useful when you are building a class that has dependencies on an entire object graph and you want to be able to control some of the values in the object graph that gets created automatically.

For example, if you're building a Book, and a Book has an Author which has a Publisher.  If you want to control the name of the publisher (without manually creating the entire object graph by hand), you can instead specify in the config file that when publishers are created, they should be named X:
```groovy
    testDataConfig {
        sampleData {
            'com.example.Publisher' {
                name = "Pragmatic Bookshelf"
            }
        }
    }
```

Then, when you build a Book, the Publisher is named appropriately:
```groovy
    assert "Pragmatic Bookshelf" == Book.build().author.publisher.name
```

Inside the config's sampleData closure, you specify a domain class name.  Use quotes around the fully qualified class name.

NOTE: Prior versions allowed a *Class* as a key for sampleData, but that is not longer supported. You must specify the entity name as a fully qualified *String*.

For each class specified, you can then provide the properties that you'd like populated and give it a property value to use:
```groovy
    testDataConfig {
        sampleData {
            'com.example.Hotel' {
                name = "Hilton"
            }
        }
    }
```

Using that config file in a test for a com.example.Hotel domain object with a name property would produce the following results in a test:
```groovy
    println Hotel.build().name   // prints "Hilton"
```

It follows the normal groovy config file pattern and you can also override things at an environmental level if desired.  This example shows how in development we can return "Motel 6" but production will return "Hilton".
```groovy
    testDataConfig {
        sampleData {
                'com.example.Hotel' {
                    name ="Motel 6"
                }
        }
    }
    environments {
        production {
            testDataConfig {
                sampleData {
                    'com.example.Hotel' {
                        name = "Hilton"
                    }
                }
            }
        }
    }
```

You are not required to have a TestDataConfig.groovy file.

=== Test Specific Config
It's also possible to specify a config that is used during a particular test.

Your test should implement the `TestDataBuilder` for integration tests or `BuildDataUnitTest` for unit tests. Just override the `doWithTestDataConfig` method and return a Closure just like your `TestDataConfig.groovy`:
```groovy
    Closure doWithTestDataConfig() {{->
        testDataConfig {
            sampleData {
                'config.Hotel' {
                    name = {-> "Westin" }
                }
            }
        }
    }}
```
This will merge the config provided from this method with the global configuration (if any) in `TestDataConfig.groovy`.

NOTE: The configuration is merged at the entity level, not the attribute level. In the above example, the global sample data for the `'config.Hotel'` entity will be completely replaced by this configuration.


After using this method, you'll likely want to call `TestDataConfigurationHolder.reset()` to put the configuration back to the normal config file.
```groovy
    void cleanup() {
        TestDataConfigurationHolder.reset()
    }
```


=== Generating Dynamic Values
If you have a need to have different values given to a domain object (possibly for a unique constraint), you can instead specify a closure in your config file.  This closure will be called and is expected to return the property value.  Here's an example that generates a unique title for a book:
```groovy
    testDataConfig {
        sampleData {
            'com.foo.Book' {
                def i = 1
                title = {-> "title${i++}" }   // creates "title1", "title2", ...."titleN"
            }
        }
    }
```

One thing to watch out for with this is that if your tests are expecting particular values generated by the closure, you could run into sequencing effects if your test run out of order (or you add a new test).  To get around this, you can reset the config before you run the test.  This is a good idea if you're using dynamic values:
```groovy
void setup() {
    TestDataConfigurationHolder.reset()
}
```

When a `Closure` is used as an attribute, it can additionally take 1 or 2 parameters. The first parameter is a `Map` of all of the properties that have been resolved so far. This allows you to configure defaults based on the values of other properties given or defaulted on the object. For example:
```groovy
'config.Hotel': {
    name: { ->
        i++ % 2 == 0 ? "Holiday Inn" : "Hilton"
    },
    faxNumber: { values ->
        "Fax number for $values.name"
    }
}
```
The second parameter is the instance that is currently being built. In the above example, that would be the new (unsaved) instance of `Hotel`. This is useful if you want to build associated data and you need a reference to the parent object. For example:
```groovy
'bookstore.Author': {
    books: { values, obj -> [Book.build(save: false, author: obj, title: 'James')] }
}
```
In this case, the transient `obj` instance is needed so that the `Book` instance can associate back to the parent.

NOTE: In this case, you must use the [save: false] argument, otherwise build test data will attempt to save the `Book` and fail with a transient object exception on `Author`.


=== Specifying Additional Dependencies
Occasionally it is necessary to build another object manually in your `TestDataConfig` file. Usually this will look something like this:
```groovy
    'test.Book' {
        author = {-> Author.build() }
    }
```

There are a number of reasons that you might want to do this. For complex object graphs, this may be necessary to prevent failures due to loops in the graph.
Also, for some graphs, you may need to do a build(save: false) or a findOrBuild() for a particular association. It may also just be that you want to default an optional association, since build-test-data will only build out the graph for required properties.

Regardless, this introduces a hidden dependency when building the `Book` class. If you only have `@Build([Book])` in your test case, you'll likely get a MethodMissing exception building `Author`. To resolve this issue, you may specify additional objects to mock each time Book is mocked:
```groovy
unitAdditionalBuild = ['test.Book': [test.Author]]
```

Each key is the full package name of a domain object and the value is a List of either a Class or String indicating additional domains to include whenever the key object is built.

The chain is recursive in that Author could, itself, have additional dependencies.  So if `Book` `belongsTo` an `Author` which `belongsTo` a `Publisher`, `build`ing a `Book` would give you all three without explicitly saying that a `Book` needs a `Publisher` with this:
```groovy
unitAdditionalBuild = [
    'test.Book'     : [test.Author],
    'test.Author'   : [test.Publisher]
]
```

Again, this is only needed for Unit testing as Grails includes all domain objects, by default, for integration tests.

=== Building Abstract Classes
If your domain classes reference abstract classes, build test data needs to know which concrete class to build to satisfy the dependencies.

By using the `abstractDefault` configuration option, you can override this behavior globally to indicate which specific subclass is desired for a given base class.

```groovy
    abstractDefault = [
        'test.AbstractBook'   : MyBook,
        'test.AbstractAuthor' : Tolkien
    ]
```

In this example, any time BTD needs to build an `AbstractBook`, it will build an instance of `MyBook` by default. If you only want to override the subclass for a particular domain object, you may want to consider just adding a default value in `sampleData`.

This default will also apply if you manually build an instance of an abstract class. For example, calling `AbstractBook.build()` in this example will return a `MyBook` instance.

.Behavior Change
[IMPORTANT]
Prior to version 3.3, build-test-data would automatically try to find a concrete subclass. However, this was *horribly* slow as Java makes it very difficult to accomplish this task. For this reason, it's now required to use `abstractDefaults` when subclasses are required.

=== Using a different name for TestDataConfig.groovy
In some cases you need to have a different name for `TestDataConfig.groovy`. The reason could be, that you have project that depends on several inline plugins all using this plugin. If all plugins contains `TestDataConfig.groovy` you will end up with a compile error saying that `TestDataConfig.groovy` is duplicated in your classpath.

Using a different name by setting this in application.groovy:
```groovy
grails.buildtestdata.testDataConfig = "MyTestDataConfig"
```

With Grails 3, you would add to application.yml:
```yml
    grails:
        buildtestdata:
            testDataConfig: "MyTestDataConfig"
```

and rename your `TestDataConfig.groovy` to `MyTestDataConfig.groovy`
